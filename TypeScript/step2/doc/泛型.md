# 泛型

泛型 提供了一个或多个抽象类型，只有在调用的时候才确定它的值。

泛型使用`<>`来定义抽象类型，在代码中调用该类型，实现对应效果。

## 基本用法

### 单一抽象类型

```typescript
function identity<T>(arg: T): T {
  return arg;
}
// identity<string>(123) // error
identity<string>('123'); // ok
```

### 多抽象类型

```typescript
function identity<T, K>(array: T, key: K): Boolean {
  return false;
}
// identity<string[], number>([1, 2, 3, 4], 1); //error
identity<number[], number>([1, 2, 3, 4], 1); //ok
```

### 抽象类型推测

在调用定义泛型函数时，可以不定义 `<>`中的抽象值，而直接使用函数，利用传入参数进行推测。

```typescript
// 类型推测
(function () {
  function identity<T, K>(array: T, key: K): K {
    return key;
  }
  identity([1, 2, 3, 4], 1); //ok
});

```

### 泛型约束

约束泛型可以使用`extends`关键字来处理。

```typescript
interface Sizeable {
	size: number;
}
function identity<T extends Sizeable>(queue: T): unknown {
	console.log(queue.size);
	return;
}
// identity(new Array()) // error
identity(new Map()); // ok
identity(new Set()); // ok
identity({ // ok
	size: 10
});
```

## 泛型工具类型

### typeof

`typeof` 的主要用途是在类型上下文中获取变量或者属性的类型。

#### 获取值类型

```typescript
const People = {
  name: '张飞',
  age: 19
};
interface IPeople {
  nackname: string;
  age: number;
}
function logInfo<T extends typeof People | IPeople>(people: T) {
     console.log(people);
}
logInfo({
  name: '张飞',
  age: 19
});
logInfo({
  nackname: '张飞',
  age: 19
});
```

#### 获取函数类型

```typescript
type LogInfoType = typeof logInfo // 上例中定义了 logInfo 方法
let logInfo2 :LogInfoType = (v)=>{
console.log(v.age) 
}
```

### keyof

keyof 可以获取到 接口，类型的所有key。返回一个接收类型的所有key联合类型。

```typescript
interface User {
  name: string;
  age: number;
  sex: '男' | '女';
}
function logUserInfo<T extends keyof User>(key: T, info: User) {
	console.log(info[key]);
}
logUserInfo('age', {
  name: '张三丰',
  age: 19,
  sex: '男'
});
// logUserInfo('cc', { // error
//   name: '张三丰',
//   age: 19,
//   sex: '男'
// });
```

















## 常见泛型变量代表

- K（Key）：表示对象中的键类型；
- V（Value）：表示对象中的值类型；
- E（Element）：表示元素类型。