## 基础类型

```typescript
let num: number;
let bigintValue: bigint;
let string: string;
let booleanValue: boolean;
let objectValue: object;
let SymbolValue: Symbol;
let undefinedValue: undefined;
let nullValue: null;
```

### 规则

1. 同类型只能赋值同类型的值。不可互相赋值。
2. 虽然 `biging` 和 `number` 都是数值类型，但是不可以互相赋值
3. 配置 `strictNullChecks` 设为 `false` 时候 `undefined` 和 `null` 可以赋值 给 其他类型值

## 数组 与 元组

### Array

##### 普通值数组

```typescript
// 方案1
let arr1: string[];
// 方案2
let arr2: Array<string>;
```

##### object []

```typescript
interface man {
  name: string;
  age: number;
}
let arr3: man[] = [
  {
    age: 10,
    name: '名字'
  }
];
```

### 元组

元组与数组相近，可以理解为 元组是规定了值个数，值类型的数组。

#### 定义

```typescript
let tuple: [number, string];
// tuple = []; // error
tuple = [10, '10'];
```

#### 解构

```typescript
const [age, name] = tuple;
// const [age, nanme , sex] = tuple; // error
```

#### 可选值

```typescript
type tupleType = [number, string, number?];
const tuple2: tupleType = [1, '章三']; // ok
const tuple3: tupleType = [1, '章三', 2]; // ok
// const tuple4: tupleType = [1, '章三', 3, 4]; // error
```

#### 额外值

```typescript
type tupleType = [number, string, number?];
const tuple2: tupleType = [1, '章三']; // ok
const tuple3: tupleType = [1, '章三', 2]; // ok
// const tuple4: tupleType = [1, '章三', 3, 4]; // error
```

### 只读

只读值可以使用`readonly`来定义，且该值只能给 `array`和`tuple` 使用。即使某类型是一个元组或数组也不行

```typescript
// - 只读
let v: readonly [number, string] = [10, '你好']; // ok
type = [number,string]
// let v2: readonly tupleType = [10, '你好']; // error
```

## object

对象类型，可以赋值任何引用类型。一般情况下使用`interface`定义接口所以不太常用

```typescript
let a: object;
// a = 10 // error
a = { name: '10' }; // ok
```

## 函数

### 写法

#### 定义 函数

```typescript
function sum(x:number,y:number):number;
function sum(x, y): number {
  return x + y;
}
console.log(sum(1, 1));
```

#### 定义函数表达式

```typescript
let sum2: (x: number, y: number) => number;
sum2 = function (x, y) {
  // return x + y + ''; // error
  return x + y;
};
```

#### 利用接口定义 函数类型

```typescript
interface sum3interface {
  (x: number, y: number): number;
}

const sum3: sum3interface = (x, y) => {
  return x + y;
};
```

### 参数

#### 可选参数

```typescript
// - 可选参数
function sum4(x: number, y?: number): number {
  return x + (y ? y : 0);
}
console.log(sum4(1));
```

- 如果没有设置 `strictNullChecks` 则要保证 可选参数有值才可操作。
- 可选参数后面不可有其他参数。

#### 参数默认值

```typescript
function sum5(x: number, y: number = 10): number {
  return y;
}
```

#### 剩余参数

```typescript
// - 剩余参数
function sum6(x: number, y: number, ...ags: number[]) {
  return ags.reduce((result, item, key) => result + item, x + y);
}
// sum6(1, 2, 3, 4, 5, 6, 7, '123'); // error
sum6(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
```

### 函数重载

```typescript
function ta(x: number, y: number): number;
function ta(x: string, y: string): string;
function ta(x: number | string, y: number | string) {
  if (typeof x === 'number' && typeof y === 'number') {
    return x + y;
  }
  if (typeof x === 'string' && typeof y === 'string') {
    return x + y;
  }
}

```

定义多种参数 与 返回值类型，必须有一个超类实现该方法。且必须解决上面函数的问题。

## void

`void`示没有任何类型，和其他类型是平等关系，不能直接赋值。

```typescript
 // let voidValue1: void = null; // error 不可赋值
 let voidValue: void;
 // let a: number = voidValue; // error 不可赋给其他值
 function fun(): void {} // 常用在函数无返回值
```

## never

`never` 表示永远不存在的返回值。与其他类型不同，它的主要作用是对代码进行检查。它不能接受除死循环与报错以外的返回值。

```typescript
type Foo = string | number | boolean;

  function controlFlowAnalysisWithNever(foo: Foo) {
    if (typeof foo === 'string') {
      // 这里 foo 被收窄为 string 类型
    } else if (typeof foo === 'number') {
      // 这里 foo 被收窄为 number 类型
    } else {
      // foo 在这里是 never
      const check: never = foo; // 报错 因为 次数 foo 可能是 boolean , boolean 不能负值给 never
    }
  }
```

## any

魔鬼 ，可以给任何值赋值，可以是赋予任何值。不要使用,未设置类型的值就是`any`

## unknow

与`any`类似，但是在将`unknow`值赋予其他值时，必须有类型缩小才可以。

```typescript
let a: unknown;
a = 10;
let b:number = 10;
// b = a; // error
b = typeof a === 'number' ? a : 0 // ok
```

## 类型推断

在定义值时，不需要每次都写类型，在第一次写时，ts会根据给到值来推断类型

```typescript
let a = 10;
// a = '10' //error
a = 20
```

在定义函数时，如果函数上下文可以推导出返回值类型，则可以不写返回值类型。

```typescript
function sum(x: number, b: number) {
  return x + b;
}
let c: number = sum(1, 2); // ok
// let d: string = sum(1,2) // error
```

## 联合类型

联合类型在定义类型的地方都可以使用。表示两种类型任意即可。

```typescript
let num: number | bigint = 123;
num = 123;
num = 123n;
```

# 明日再战

有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。